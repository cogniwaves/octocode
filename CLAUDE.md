# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

OctoCode is an AI-powered development platform built with Next.js 14 that uses intelligent agents to automate software development workflows. The platform features a Master Orchestrator that decomposes complex development prompts into specialized tasks executed by domain-specific agents (Frontend, Backend, DevOps, etc.).

## Tech Stack

### Frontend
- **Framework**: Next.js 14 with App Router
- **Styling**: Pure MD3 style
- **State Management**: Zustand
- **TypeScript**: Full type safety throughout
- **Real-time**: WebSocket via Socket.io-client

### Backend
- **API Layer**: Next.js 14 API Routes (`app/api/`)
- **Database**: Prisma ORM + SQLite (MVP) → PostgreSQL (production)
- **Authentication**: NextAuth.js (prepared for multi-tenant)
- **Real-time**: Socket.io server
- **AI Integration**: Anthropic SDK

### Development
- **Package Manager**: pnpm
- **Testing**: Vitest + Playwright
- **Containerization**: Docker Compose with `oc_*` container naming convention
- **Database Migrations**: Prisma migrate

## Architecture

### Project Structure (Planned)
```
octocode/
├── app/                          # Next.js 14 App Router
│   ├── (auth)/                   # Auth routes grouped
│   ├── api/                      # API Routes
│   │   ├── agents/               # Agent endpoints
│   │   ├── projects/             # Project management
│   │   └── websocket/            # Real-time communication
│   ├── dashboard/                # Main application
│   ├── globals.css               # Global MD3 styles
│   └── layout.tsx                # Root layout
├── components/                   # Shared UI components
│   ├── ui/                       # shadcn/ui components
│   ├── agents/                   # Agent-specific components
│   └── workflow/                 # Workflow builder components
├── lib/                          # Utilities & configs
│   ├── agents/                   # Agent logic
│   ├── db/                       # Database utilities
│   └── utils.ts                  # Helper functions
├── prisma/                       # Database schema & migrations
└── docker/                       # Container configurations
```

### Core Agent Architecture
- **BaseAgent**: Abstract class that all agents extend
- **MasterOrchestrator**: Main coordinator that decomposes prompts and manages workflow
- **DecompositionAgent**: Analyzes prompts and creates task breakdown
- **Specialist Agents**: Domain-specific agents (Frontend, Backend, DevOps, etc.)

Each agent is designed with multi-tenant support from the start, accepting `projectId` and `userId` parameters.

### Real-time Communication
- WebSocket integration for live progress updates
- Task progress tracking with status updates
- Real-time workflow visualization in dashboard

## Database Design

Multi-tenant ready schema with user isolation:
- Users can have multiple Projects
- Projects contain Tasks executed by Agents
- Schema prepared for future Organization model
- All models include proper timestamps and relationships

## Development Commands

### Docker Development Environment
```bash
# Start all services
docker-compose up -d

# View logs
docker-compose logs -f oc_app

# Access app container
docker exec -it oc_app bash

# Rebuild and restart
docker-compose up --build
```

### Database Operations
```bash
# Generate Prisma client
pnpm prisma generate

# Run migrations
pnpm prisma migrate dev

# Reset database
pnpm prisma migrate reset

# Open Prisma Studio
pnpm prisma studio
```

### Development Server
```bash
# Install dependencies
pnpm install

# Start development server
pnpm dev

# Run tests
pnpm test

# Build for production
pnpm build
```

## Implementation Guidelines

### Agent Development
- All agents must extend `BaseAgent` class
- Implement progress tracking with `updateProgress()` method
- Use WebSocket notifications for real-time updates
- Design with multi-tenant isolation in mind

### API Routes
- Use Next.js 14 App Router structure (`app/api/`)
- Implement proper error handling and status codes
- Include authentication middleware for protected routes
- Use TypeScript for request/response typing

### Frontend Components
- Use shadcn/ui components as base
- Implement responsive design with MD3
- Create reusable components in appropriate directories
- Use Zustand for state management

### Database Changes
- Always use Prisma migrations for schema changes
- Test migrations thoroughly before applying
- Maintain multi-tenant compatibility in schema design
- Use proper TypeScript types generated by Prisma

## Container Naming Convention

All Docker containers use the `oc_` prefix:
- `oc_app`: Main Next.js application
- `oc_database`: PostgreSQL database (production)
- `oc_redis`: Redis for sessions/caching (future)

## Migration Path

The project is designed with a clear migration path:
1. **MVP**: Single-user, SQLite, local files
2. **Multi-user**: PostgreSQL, user isolation
3. **Multi-tenant**: Organization model, resource quotas
4. **Cloud Native**: Vercel deployment, external services
- Add to memory  "Use Material Design 3"
- Add to memory, always start from a clean git state. If not clean commit before starting
- add to memory:  All framework concerns should be directed to nextjs-specialist
- Add to memory all docker and container MACD, design, operation, etc should be handed to docker-architect
- Add to memory: THe design system should be developped and maintained by material-design-3-specialist. It is responsible for all UI related decision
- Add to memory: Always use the debugging expert to debug th application
- Add to memory: All planning tasks for new feature should be handed to the feature-planner.

## Docker Access URLs

### Development Environment
- **Application**: http://localhost:3002 (mapped from container port 3000)
- **Socket.IO**: http://localhost:3003 (mapped from container port 3001)  
- **PostgreSQL**: localhost:5435 (direct database access)
- **Redis**: localhost:6380 (direct cache access)

### Container Status Commands
```bash
# Check running containers
docker compose -f docker-compose.dev.yml ps

# View resource usage
docker stats

# Health check status
docker inspect oc_app_dev --format='{{.State.Health.Status}}'
```
